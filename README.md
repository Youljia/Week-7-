# Week-7-



## C++语言学习

### 操作符重载

- **为什么需要操作符重载**

  ​		当操作数是操作符不支持的类型时（比如自定义的类，结构体）

- **操作符重载语法**

  ` 数据类型 operator操作符（形参）`

  ```c++
  Complex operator+(Complex& c1, Complex& c2)
  {
  	int a = c1.a + c2.a;
  	int b = c1.b + c2.b;
  	Complex c3(a, b);
  	return c3; 
  }
  //如果返回值是引用，那么函数执行完毕c3被回收，就是未知空间了！
  ```

- 重载规则

  1. 不允许自定义操作符，只能对已有操作符进行重载
  2. 不可以被重载的操作符（3个）
  3. 重载不会改变优先级
  4. 重载不可以改变操作数的个数
  5. 重载形参不可以设定默认值
  6. 重载后操作符的功能不变
  7. 重载需要和自定义类一起用
  8. 重载可以是全局，友元，类中函数				

- 代码实战

  1. 加减法

     ```c++
     	//调用方法
     	Complex c3 = c1 + c2;//隐式写法
     	c3 = operator+(c1, c2);//显式写法
     ```

  2. 双目运算符

     ```c++
     	Complex& operator-=(Complex& another)
     	{
     		this->a -= another.a;
     		this->b -= another.b;
     		return *this;
     	}
     	//对c1本身进行操作，c1也要变，所以返回c1，c1不会被释放
     ```

  3. 单目运算符

     ```c++
     	a++++;//报错，a++返回一个固定值
     	++++a;//可运行
     
     	//自增++a
     	Complex& operator++(Complex& c1)
     	{
     		c1.a += 1;
     		return c1;
     	}
     	//自增a++
     	const Complex& operator++(Complex& c1,int)
     	{
     		Complex temp = c1;
     		c1.a += 1;
     		return temp;
     	}
     ```

  4. 左移右移操作符（只能使用全局函数）

     ```c++
     	int a,b;
     	cout << a << b;//左移操作符
     	//<<的返回值是cout
     
     
     	//类中重载函数
     	istream& operator>>(istream& ci)
     	{
     		cout << "a = " << endl;
     		ci >> this->a;
     		cout << "b = " << endl;
     		ci >> this->b;
     		return ci;
     	}
     
     	//调用
     	cin >> c1;//报错！
     	c1.operator>>(cin);//显示写法可以
     	c1 >> cin;//隐式写法，含义变了，不可取！
     ```

  5. 伪函数（仿函数）--重载小括号

  6. 重载数组类的操作符

     ​	输入输出操作符，[]取值操作符，==操作符

### 递归与链表

- 递归的本质

  ​	将原来的问题转化为更小的问题，注意递归的“宏观概念”。

- 递归算法如何写？

  ​	找准两点

  1. 找准最基本的问题，即递归调用终止的条件
  2. 将原问题化成更小的问题，并找出原问题的答案和更小问题答案之间的联系

- 递归调用的代价

  1. 函数调用
  2. 系统栈空间

### 归并排序法

- 是一种基于递归的排序方法

- 不断二分进行排序，然后将已经排好序的数组合并

  

  
